<html>
  <head>
    <!-- <script src="./web3.min.js"></script> -->
    <!-- <script src="https://cdn.jsdelivr.net/npm/p5@1.3.1/lib/p5.js"></script> -->
    <script
      src="https://code.jquery.com/jquery-3.5.1.min.js"
      integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0="
      crossorigin="anonymous">
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@alch/alchemy-web3@latest/dist/alchemyWeb3.min.js"></script>
    <link href=css/bart.css rel=stylesheet> 
    <meta charset="UTF-8">
    <script type='text/javascript' src='bundle.js'>
      /*Seem to have to load bundle.js here for all the solidity calls below
       *to work
       */
    </script>

  </head>
  
  <body>
    <main>
      <div class="titlebar"><h1 class="titlebar">crypt0den</h1></div>

      <!-- The online/primary/secondary buttons are just for testing -->
      <div class="bouton">
        <!-- <button class="btn btn-1" id="loadApp1">online</button>
        <button class="btn btn-1" id="loadApp2">primary</button>
        <button class="btn btn-1" id="loadApp3">secondary</button> -->
        <button class="btn btn-1" id="info">about</button>
        <button class="btn btn-1" id="chain">launch</button>
      </div>

      <div id="app"></div>
      <div id="crypt0den_out"></div>
    </main>
  </body>


<script type="text/javascript">
    let e,tokenID,numTokens,ownC,own0,own1,own2,ownContract,TokLimit;
    let runVersion;

    /*These handlers go with the online/primary/secondary buttons above, not needed in production*/
    /*$('#loadApp1').on("click", function () {
      console.log("executing 1");
      $.when($.getScript('https://cdn.jsdelivr.net/npm/p5@1.3.1/lib/p5.js').done(console.log("p5js loaded")));
      $.when($.getScript('ab1.js').done(preload()))});

    $('#loadApp2').on("click", function () {
      console.log("executing 2");
      $.when($.getScript('https://cdn.jsdelivr.net/npm/p5@1.3.1/lib/p5.js').done(console.log("p5js loaded")));
      $.when($.getScript('ab2.js').done(preload()))});

    $('#loadApp3').on("click", function () {
      console.log("executing 3");
      $.when($.getScript('https://cdn.jsdelivr.net/npm/p5@1.3.1/lib/p5.js').done(console.log("p5js loaded")));
      $.when($.getScript('ab3.js').done(preload()))});*/

      $('#chain').on("click",function () {
          if(ownC == null) {
            console.log('Launch handler ERROR => ',e);
            runVersion = 'ab3.js'; //default, just in case the chain call fails
          } else {
            if(ownC === own0) {
              runVersion = 'ab1.js'; //current owner is creator
            } else if(ownC === own1) {
              runVersion = 'ab2.js'; //current owner is primary mkt buyer
            } else if(ownC === own2) {
              runVersion = 'ab3.js'; //current owner is secondary mkt buyer
            } else {
              console.log('Launch handler ERROR => ',tokenID,' ',ownC,'  ',own0,' ',own1,' ',own2);
            }
          };
        $.when($.getScript('https://cdn.jsdelivr.net/npm/p5@1.3.1/lib/p5.js').done(console.log("p5js loaded")));  
        $.when($.getScript(runVersion), function() {preload()});
      });



/*    $('#chain').on("click", function () {
      console.log("executing chain");
       $.when($.getScript('bundle.js')
        //.done(console.log("bundle.js eti => ",window.eti()))
        .done(e = window.eti())
        .then((response) => {return response;} )
        )});*/

    /*This comes from the 'browserify ethinterface.js --standalone *eti > bundle.js' which converts server side things like 'require'
    *into client side javascript. Somehow the eti() call results
    *from the bundle.js being sourced above; anyway, it avoids *having to explicitly call delete_identity() which wasn't working
    */
    const eticall = window.eti()
      .then((response) => {return response;})   

    /*Parses the returned promise/string from the solidity view       *function 'delete_ID()'
    */
    const getState = () => {
      eticall.then((a) => {
        tokenID = Number(a.substr(2,64));
        numTokens = Number(a.substr(66,64));
        TokLimit = Number(a.substr(130,64));
        ownC = a.substr(194,64);
        own0 = a.substr(258,64);
        own1 = a.substr(322,64);
        own2 = a.substr(386,64);
        ownContract = a.substr(450,64)
        console.log("Contract state ID=> ",tokenID,'\n\n numTokens ',numTokens,'\n\n TokenLim ',TokLimit,'\n\n ownC ',ownC,'\n\n own0 ',own0,'\n\n own1 ',own1,'\n\n own2 ',own2,'\n\n','\n\n ownT ',ownContract);
      })
    };

    getState();

  </script>


 
<script>
  document.getElementById('info').addEventListener("click",about);

  function about() {
    let markup = '<br><br><h2>What am I looking at?</h2><br>';
    
    markup += '<p>This website shows images \& text related to the Simulation Argument.  They are, respectively, taken from an Unreal Engine simulation, and a questionnaire sent to various researchers in the field.</p><br>';
    
    markup += '<p>This site is NFT-wrapped, meaning: when a user enters an URL, the site consults an ERC721-based smart contract.  Depending on the contract state, the website renders differently: today (May 2021) it is basically identical to an IRL piece curator Owen Duffy selected for Mana Contemporary.  When/if there occurs a primary sale (as recorded on the blockchain), the Javascript code will cause it to degrade or glitch itself.  Upon a subsequent (secondary) sale, it will degrade again, becoming banal wallpaper.  </p><br>'

    markup += '<br><br><h2>Why is this interesting?</h2><br>'

    markup += '<p>In an NFT context, it explores certain capacity/cost (and yes, ecological) issues of smart contracts that owe to their technical constraints and their ideological history.  As institutional critique, it distinguishes between art-as-public good (i.e. sitting in a public gallery) and art-as-private consumption good (i.e. bauble, tax-dodge, a funner way to hodl crypto gains, etc.).  Thirdly, the idea of software agents talking to each other is kind of cool; whilst totally commonplace atm, perhaps some day emulations will be autonomous  - or even indifferent - to us.  Lastly, the (auto-)destruction of an artwork continues to be interesting question for dematerialised, conceptual, and/or digital practices.</p><br>'

    markup += '<br><br><h2>What do NFTs have to do with the Simulation Argument?</h2><br>'

    markup += '<p>Elon Musk?</p><br>'

    markup += '<br><br><h2>Will this work on my device?</h2><br>'

    markup += '<p>Works best on Apple or Linux desktops running Chrome.  Works fitfully on iPhone running Chrome or Firefox.  Refresh if it freezes.  IT are on it.</p><br>'

    markup += '<br><br><h2>Acknowledgements</h2><br>'

    markup += '<p>The code is cobbled together: Solidity/Hardhat/web3.js stuff from contributors online; Alchemy \& OpenZeppelin tutorials; the Autoglyphs project by Larvalabs; Ethereum Foundation tutorials and Whitepaper.  For Javascript, the p5js and Processing.org teams, miscellaneous GL shader contributors, notably Tommy Bazar\'s Mandelbulb raymarcher for Unreal Engine. For the Simulation Argument, Nick Bostrom and his collaborators/correspondents online, as well as Preston Greene at NTU Singapore.  Language help from Bob/Alyssa Levy and Stephen/Yoshino Laughton.  And of course, Sarah Pettitt for her technical expertise.  Lastly, Owen Duffy for making me do this.</p><br>'

    markup += '<h2>Is this on OpenSea? How do I buy it?</h2><br>'

    markup += '<p>It is not on OpenSea or the other exchanges.  Think of this as a unique work, with caveats: while the smart contract itself is immutable and singly instanced (i.e. one token), this website is uneditioned, copy-able, mutable (like many other NFTs).  To buy please contact Kanad Chakrabarti @ukc10014 on IG, Twitter, or Discord.  For a private collector, it will cost ETH 15 (settled in USD, EUR, GBP or JPY), which at current levels, is about 10x the video at Mana Contemporary. Discounts for Systemically Important Cultural Institutions lol.</p><br>'    

    document.getElementById("app").innerHTML = markup;
  }
</script>


  
</html>